"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyActionFunction = exports.getExtraFromArtifact = exports.addAnnotationToNode = exports.addExtraToNodeArtifact = exports.importState = exports.goToNode = exports.createProvenanceGraph = void 0;
var applyChange = require('deep-diff').applyChange;
var NodeInterfaces_1 = require("../Interfaces/NodeInterfaces");
var generateUUID_1 = require("../Utils/generateUUID");
var generateTimeStamp_1 = require("../Utils/generateTimeStamp");
var DeepCopy_1 = require("../Utils/DeepCopy");
var DeepDiff_1 = require("../Utils/DeepDiff");
function createProvenanceGraph(state) {
    var _a;
    var root = {
        id: generateUUID_1.default(),
        label: 'Root',
        metadata: {
            createdOn: generateTimeStamp_1.default(),
            type: 'Root'
        },
        children: [],
        state: state,
        getState: function () {
            return state;
        },
        ephemeral: false,
        bookmarked: false
    };
    var graph = {
        nodes: (_a = {},
            _a[root.id] = root,
            _a),
        root: root.id,
        current: root.id
    };
    return graph;
}
exports.createProvenanceGraph = createProvenanceGraph;
function goToNode(graph, id) {
    var newGraph = DeepCopy_1.default(graph);
    var newCurrentNode = graph.nodes[id];
    if (!newCurrentNode) {
        throw new Error('No such node exists');
    }
    newGraph.current = newCurrentNode.id;
    return newGraph;
}
exports.goToNode = goToNode;
function importState(graph, initalState, importedState) {
    var newGraph = DeepCopy_1.default(graph);
    var currentId = newGraph.current;
    var currentState = DeepCopy_1.default(graph.nodes[currentId].getState());
    var createNewStateNode = function (parent, state, diffs, ephemeral) { return ({
        id: generateUUID_1.default(),
        label: 'Import Node',
        metadata: {
            createdOn: generateTimeStamp_1.default()
        },
        artifacts: {
            diffs: diffs,
            extra: []
        },
        parent: parent,
        children: [],
        state: state,
        getState: function () {
            return state;
        },
        ephemeral: false,
        bookmarked: false
    }); };
    var createNewDiffNode = function (parent, previousStateID, diffs, ephemeral) { return ({
        id: generateUUID_1.default(),
        label: 'Import Node',
        metadata: {
            createdOn: generateTimeStamp_1.default()
        },
        artifacts: {
            diffs: diffs,
            extra: []
        },
        parent: parent,
        children: [],
        lastStateNode: previousStateID,
        diffs: diffs,
        getState: function () {
            var _state = newGraph.nodes[previousStateID].getState();
            var state = DeepCopy_1.default(_state);
            var diffsTemp = diffs;
            if (diffsTemp.length === 0) {
                return state;
            }
            diffsTemp.forEach(function (diff) {
                applyChange(state, null, diff);
            });
            return state;
        },
        ephemeral: false,
        bookmarked: false
    }); };
    var currNode = graph.nodes[currentId];
    var backCounter = 0;
    var previousState = undefined;
    var previousStateID = '';
    var d = true;
    if (NodeInterfaces_1.isChildNode(currNode)) {
        if (NodeInterfaces_1.isStateNode(currNode)) {
            previousState = currNode.getState();
            previousStateID = currNode.id;
        }
        else {
            previousState = graph.nodes[currNode.lastStateNode].getState();
            previousStateID = currNode.lastStateNode;
        }
    }
    else {
        d = false;
        previousState = currNode.getState();
        previousStateID = currNode.id;
    }
    var newState = importedState;
    var parentId = graph.current;
    var diffs = DeepDiff_1.default(previousState, newState);
    if (diffs === undefined) {
        diffs = [];
    }
    // TODO:: figure out how to count nested keys
    if (d && Object.keys(previousState).length / 2 < diffs.length) {
        d = false;
    }
    var newNode = d
        ? createNewDiffNode(parentId, previousStateID, diffs, false)
        : createNewStateNode(parentId, newState, diffs, false);
    newGraph.nodes[newNode.id] = newNode;
    newGraph.nodes[currentId].children.push(newNode.id);
    newGraph.current = newNode.id;
    return newGraph;
}
exports.importState = importState;
function addExtraToNodeArtifact(graph, id, extra) {
    var newGraph = DeepCopy_1.default(graph);
    var node = newGraph.nodes[id];
    if (NodeInterfaces_1.isChildNode(node)) {
        node.artifacts.extra.push({
            time: generateTimeStamp_1.default(),
            e: extra
        });
    }
    else {
        throw new Error('Cannot add artifacts to Root Node');
    }
    return newGraph;
}
exports.addExtraToNodeArtifact = addExtraToNodeArtifact;
function addAnnotationToNode(graph, id, annotation) {
    var newGraph = DeepCopy_1.default(graph);
    var node = newGraph.nodes[id];
    if (NodeInterfaces_1.isChildNode(node)) {
        node.artifacts.annotation = annotation;
    }
    else {
        throw new Error('Cannot add annotation to Root Node');
    }
    return newGraph;
}
exports.addAnnotationToNode = addAnnotationToNode;
function getExtraFromArtifact(graph, id) {
    var node = graph.nodes[id];
    if (NodeInterfaces_1.isChildNode(node)) {
        return node.artifacts.extra;
    }
    throw new Error('Root does not have artifacts');
}
exports.getExtraFromArtifact = getExtraFromArtifact;
function applyActionFunction(graph, label, action, complex, ephemeral, args, metadata, artifacts) {
    if (artifacts === void 0) { artifacts = {}; }
    var newGraph = DeepCopy_1.default(graph);
    var currentId = newGraph.current;
    var currentState = DeepCopy_1.default(graph.nodes[currentId].getState());
    var createNewStateNode = function (parent, state, diffs, ephemeral) { return ({
        id: generateUUID_1.default(),
        label: label,
        metadata: __assign({ createdOn: generateTimeStamp_1.default() }, metadata),
        artifacts: __assign({ diffs: diffs, extra: [] }, artifacts),
        parent: parent,
        children: [],
        state: state,
        getState: function () {
            return state;
        },
        ephemeral: ephemeral,
        bookmarked: false
    }); };
    var createNewDiffNode = function (parent, previousStateID, diffs, ephemeral) { return ({
        id: generateUUID_1.default(),
        label: label,
        metadata: __assign({ createdOn: generateTimeStamp_1.default() }, metadata),
        artifacts: __assign({ diffs: diffs, extra: [] }, artifacts),
        parent: parent,
        children: [],
        lastStateNode: previousStateID,
        diffs: diffs,
        getState: function () {
            var _state = newGraph.nodes[previousStateID].getState();
            var state = DeepCopy_1.default(_state);
            var diffsTemp = diffs;
            if (diffsTemp.length === 0) {
                return state;
            }
            // console.log(JSON.stringify( {_state, diffs}, null, 4 ));
            diffsTemp.forEach(function (diff) {
                applyChange(state, null, diff);
            });
            // console.log(state)
            return state;
        },
        ephemeral: ephemeral,
        bookmarked: false
    }); };
    var currNode = graph.nodes[currentId];
    var backCounter = 0;
    var previousState = undefined;
    var previousStateID = '';
    var d = true;
    if (NodeInterfaces_1.isChildNode(currNode)) {
        if (NodeInterfaces_1.isStateNode(currNode)) {
            previousState = currNode.getState();
            previousStateID = currNode.id;
        }
        else {
            previousState = graph.nodes[currNode.lastStateNode].getState();
            previousStateID = currNode.lastStateNode;
        }
    }
    else {
        d = false;
        previousState = currNode.getState();
        previousStateID = currNode.id;
    }
    var newState = args ? action.apply(void 0, __spreadArrays([currentState], args)) : action(currentState);
    var parentId = graph.current;
    var diffs = DeepDiff_1.default(previousState, newState);
    if (diffs === undefined) {
        diffs = [];
    }
    // TODO:: figure out how to count nested keys
    if (d && Object.keys(previousState).length / 2 < diffs.length) {
        d = false;
    }
    var newNode = d && !complex
        ? createNewDiffNode(parentId, previousStateID, diffs, ephemeral)
        : createNewStateNode(parentId, newState, diffs, ephemeral);
    newGraph.nodes[newNode.id] = newNode;
    newGraph.nodes[currentId].children.push(newNode.id);
    newGraph.current = newNode.id;
    return newGraph;
}
exports.applyActionFunction = applyActionFunction;
//# sourceMappingURL=ProvenanceGraphFunction.js.map