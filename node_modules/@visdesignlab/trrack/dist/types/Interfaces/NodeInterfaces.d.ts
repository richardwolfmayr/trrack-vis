export declare type NodeID = string;
export interface NodeMetadata<S> {
    createdOn?: number;
    type?: S | 'Root';
    [key: string]: any;
}
interface DiffAnyProps {
    [key: string]: any;
}
export declare type Diff = DiffAnyProps & {
    path: string[];
};
export interface Extra<A> {
    time: number;
    e: A;
}
export interface Artifacts<A> {
    diffs?: Diff[];
    annotation?: string;
    extra: Extra<A>[];
    [key: string]: any;
}
export interface BaseNode<T, S> {
    id: NodeID;
    label: string;
    metadata: NodeMetadata<S>;
    children: NodeID[];
    getState: () => T;
    ephemeral: boolean;
    bookmarked: boolean;
}
export interface RootNode<T, S> extends BaseNode<T, S> {
    state: T;
}
export interface ChildNode<T, S, A> extends BaseNode<T, S> {
    parent: NodeID;
    artifacts: Artifacts<A>;
}
export interface StateNode<T, S, A> extends RootNode<T, S>, ChildNode<T, S, A> {
}
export interface DiffNode<T, S, A> extends ChildNode<T, S, A> {
    diffs: Diff[];
    lastStateNode: NodeID;
}
export declare type ProvenanceNode<T, S, A> = RootNode<T, S> | StateNode<T, S, A> | DiffNode<T, S, A>;
export declare type Nodes<T, S, A> = {
    [key: string]: ProvenanceNode<T, S, A>;
};
export declare type CurrentNode<T, S, A> = ProvenanceNode<T, S, A>;
export declare function isStateNode<T, S, A>(node: ProvenanceNode<T, S, A>): node is StateNode<T, S, A>;
export declare function isDiffNode<T, S, A>(node: ProvenanceNode<T, S, A>): node is DiffNode<T, S, A>;
export declare function isChildNode<T, S, A>(node: ProvenanceNode<T, S, A>): node is DiffNode<T, S, A> | StateNode<T, S, A>;
export {};
